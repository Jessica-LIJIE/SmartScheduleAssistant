# 一、总体开发思路

本系统采用前后端分离架构，通过前端维护对话上下文、后端提供无状态对话生成接口，实现多轮对话能力。

**前端职责：**
- 管理会话（session）
- 维护历史对话上下文
- 拼接 prompt 并调用后端接口

**后端职责：**
- 接收 prompt
- 调用大语言模型 API
- 记录必要的对话日志（可选）
- 返回模型生成结果

该方案避免了复杂的后端状态管理，实现成本低、扩展性好、符合教学项目要求。

---

# 二、开发环境与技术选型

## 1. 前端

**技术栈：**
- Vue / React（任选其一）
- Axios（HTTP 请求）

**主要模块：**
- 对话界面（Chat UI）
- 会话状态管理（内存 / localStorage）
- Prompt 构造逻辑

## 2. 后端

**技术栈：**
- Python + FastAPI（推荐）

**核心能力：**
- RESTful API
- 调用 LLM 接口（如 OpenAI / 本地模型）
- 数据库存储（可选）

## 3. 数据库（可选）

**MySQL / SQLite**

**用于：**
- 用户信息
- 会话记录
- 对话日志（非必须参与推理）

---

# 三、详细开发流程

## 第一阶段：系统初始化与基础架构搭建

### Step 1：项目结构初始化

**后端目录结构示例**
```
backend/
├── main.py
├── api/
│   └── chat.py
├── service/
│   └── llm_service.py
├── model/
│   └── schemas.py
├── database/
│   └── db.py
└── requirements.txt
```

**前端目录结构示例**
```
frontend/
├── src/
│   ├── components/
│   │   └── ChatWindow.vue
│   ├── api/
│   │   └── chat.js
│   └── store/
│       └── chatStore.js
```

### Step 2：后端基础服务启动

创建 FastAPI 应用，实现健康检查接口：
```python
@app.get("/health")
def health_check():
    return {"status": "ok"}
```
验证后端可正常启动，为后续接口开发打基础。

---

## 第二阶段：单轮对话功能实现

目标：先跑通 “一句话 → 模型 → 一句话”

### Step 3：实现最简对话 API

API 功能：
- 接收 prompt
- 调用大模型
- 返回回复

**请求：**
```
POST /api/chat
{
  "prompt": "你好"
}
```

**响应：**
```json
{
  "reply": "你好，有什么可以帮助你的？"
}
```

此阶段不考虑上下文、不存数据库。

### Step 4：前端单轮对话接入

- 输入框提交用户问题
- 调用 `/api/chat`
- 显示返回内容

确认：
- 请求成功
- UI 正常渲染
- 后端调用模型无异常

---

## 第三阶段：多轮对话（核心阶段）

### Step 5：前端维护对话上下文

前端维护一个消息数组：
```json
[
  {"role": "user", "content": "你好"},
  {"role": "assistant", "content": "你好，有什么可以帮你？"},
  {"role": "user", "content": "介绍一下强化学习"}
]
```

每次新请求时：
- 将历史消息拼接成 prompt
- 再附加最新用户输入
- 一并发送给后端

### Step 6：Prompt 构造策略

示例拼接方式：
```
用户：你好
助手：你好，有什么可以帮你？
用户：介绍一下强化学习
```

或 JSON 形式（推荐）：
```json
{
  "messages": [
    {"role": "user", "content": "你好"},
    {"role": "assistant", "content": "你好，有什么可以帮你？"},
    {"role": "user", "content": "介绍一下强化学习"}
  ]
}
```

### Step 7：后端支持多轮对话输入

修改后端接口：
```
POST /api/chat
{
  "session_id": "abc123",
  "messages": [...]
}
```

后端：
- 不保存上下文
- 直接将 messages 传给模型
- 返回最新 assistant 回复

---

## 第四阶段：会话管理与优化

### Step 8：前端会话（Session）管理

生成 session_id：
- UUID
- 时间戳 + 随机数

支持功能：
- 新建会话
- 清空上下文
- 切换历史会话（可选）

### Step 9：上下文长度控制（重要）

为避免 prompt 过长：
- 仅保留最近 N 轮对话（如 5～10 轮）
- 或对历史内容进行摘要（进阶）

示例策略：
- 仅保留最近 10 条 messages

---

## 第五阶段：数据库与日志（加分项）

### Step 10：对话日志入库（非推理）

在后端：
- 记录：
  - session_id
  - 用户输入
  - 模型回复
  - 时间戳
- 不参与下一轮推理

作用：
- 项目展示
- 调试分析
- 实验统计

---

## 第六阶段：测试与完善

### Step 11：功能测试

重点验证：
- 多轮对话是否连贯
- 切换会话是否互不干扰
- 清空上下文是否生效
- 长对话是否被正确截断

### Step 12：异常与边界处理

- 网络异常
- 模型接口超时
- 空输入
- 返回内容过长

---
